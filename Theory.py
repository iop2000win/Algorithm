'''
크루스칼 알고리즘 / 프림 알고리즘의 개념이
최단거리 계산 문제와 유사해 보이지만, 결정적으로 다른 부분이 있다.

최단 거리 문제의 경우,
주어진 그래프에 대해서, 시작점 / 종료지점이 주어지고 시작점으로 부터 종료지점까지 소모되는
비용을 최소로 하는 방법을 찾는 것인 반면

크루스칼 / 프림 알고리즘의 경우,
주어진 그래프에 대해서, 그래프의 모든 노드를 연결하는 가장 최소 비용의 방법을 찾는 것이다.
'''




'''
=======================================================================================================================
<<<다익스트라 알고리즘>>>

시작점 -> 목적지 로 가는 최단 거리를 구할 때 사용하는 알고리즘 중 하나로,
목적지로의 최단 거리 뿐 아니라, 시작점으로 부터 연결된 모든 노드에 대한 최단 거리를 구하는 작업이다.

알고리즘의 기본 개념은,
각 노드에 대한 최단 거리 리스트를 생성한 후, 해당 값을 계속 업데이트 해나가는 것이다.

ex)
graph =[[],
		[(2, 2), (3, 5), (4, 1)], # 1번 node에 연결된 node와 각 비용
		[(3, 3), (4, 2)], # 2번 node에 연결된 node와 각 비용
		[(2, 3), (6, 5)], # 3번 node에 연결된 node와 각 비용
		[(3, 3), (5, 1)], # 4번 node에 연결된 node와 각 비용
		[(3, 1), (6, 2)], # 5번 node에 연결된 node와 각 비용
		[]] # 6번 node에 연결된 node와 각 비용]

시작노드 = 1번

step 1.	시작노드에 직접 연결된 모든 노드에 대한 비용 업데이트
		1번 노드에 연결된, 2번/3번/4번 노드에 대한 비용 업데이트

step 2.	시작노드에서 가장 가까운 노드로 이동 / 해당 노드에 대한 방문 처리
		비용이 가장 적은 4번 노드로 이동
		4번 노드 방문 처리

step 3. 이동한 노드에 직접 연결된 모든 노드에 대한 비용 업데이트
		4번 노드에는 현재 3번/5번 노드가 연결되어 있다.
		5번 노드의 경우) 1 -> 4 -> 5로 이동한 것이며 따라서 비용은, 1 -> 4 (1) / 4 -> 5 (1) 을 더해 비용 2로 업데이트
		3번 노드의 경우) 1 -> 4 -> 3으로 이동한 것이며 따라서 비용은, 1 -> 4 (1) / 4 -> 3 (3) 을 더해 비용이 4로 계산된다.
		하지만! 3번 노드의 경우 1번 노드에 직접 연결되었었기 때문에 현재 비용이 5로 업데이트 되어있다.
		이런 경우 기존의 비용과 새로 계산된 비용을 비교하여 업데이트를 진행한다.
		위 경우, 1번에서 3번으로 직접가는 비용(5) 보다 1번에서 4번을 거쳐 3번으로 가는 비용(4)이 더 낮으므로 4로 업데이트

step 4. 다시 비용이 가장 적은(가장 가까운) 노드를 탐색한 후 이동
		1 -> 2 (2)
		1 -> 3 (4)
		1 -> 4 (1) (방문 완료)
		1 -> 5 (1)
		
		현재의 비용 값과 방문 여부를 확인하여, 다음 노드를 결정
		이 경우에는 4번 노드 / 5번 노드 방문 비용이 동일하지만 4번은 이미 방문했던 노드이기 때문에 4번이 아닌,
		5번 노드로 이동하여 동일한 작업을 반복한다.

		모든 노드에 대한 방문이 끝나고나면, 각 노드에 대한 최단 거리가 계산 된다.
		*** 그래프의 모든 노드는 연결되어 있다.
'''

def get_smallest_node():
	'''
	방문하지 않은 노드 중, 가장 비용이 낮은 노드를 찾는 작업
	'''
	min_value = INF # INF = int(1e9)
	index = 0

	for i in range(1, n+1):
		if (distance[i] < min_value) and (not visited[i]):
			min_value = distance[i]
			index = i

	return index


def dijkstra(start):
	'''
	start node에 대한 기본 처리
	'''
	distance[start] = 0
	visited[start] = True

	for (node, cost) in graph[start]:
		distance[node] = cost

	'''
	방문하지 않은 노드 중, 가장 비용이 낮은 노드를 찾은 후(방문 처리 수행),
	해당 노드에서 연결된 다른 노드로의 비용을 계산하여, distance 리스트 업데이트

	기존 코스트
	신규 코스트 - 현재 노드까지의 비용 + 현재 노드에서 다음 노드까지의 비용

	두 코스트 비교 후, 더 적은 비용으로 업데이트
	'''
	for i in range(n-1):
		now = get_smallest_node()
		visited[now] = True

		for (node, cost) in graph[now]:
			new_cost = distance[now] + cost

			if new_cost < distance[node]:
				distance[node] = new_cost

	return


# heapq를 이용한 다익스트라 알고리즘
import heapq

def dijkstra_heapq(start):
	q = []
	heapq.heappush(q, (0, start)) # heapq에 입력되는 것이 방문처리라고 생각하면 됨
	distance[start] = 0

	while q:
		dist, now = heapq.heappop()

		# 현재 노드가 이미 처리된 적이 있는 노드인가?
		if distance[now] < dist:
			continue

		for node, cost in graph[now]:
			new_cost = dist[now] + cost
			if dist[node] > new_cost:
				dist[node] = new_cost

				heapq.heappush(q, (new_cost, node))



'''
=======================================================================================================================
'''


'''
=======================================================================================================================
<<<플로이드 워셜 알고리즘>>>

모든 노드에서 모든 노드로의 최단 거리를 구하는 알고리즘
'''
