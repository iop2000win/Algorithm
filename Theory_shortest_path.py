'''
크루스칼 알고리즘 / 프림 알고리즘의 개념이
최단거리 계산 문제와 유사해 보이지만, 결정적으로 다른 부분이 있다.

최단 거리 문제의 경우,
주어진 그래프에 대해서, 시작점 / 종료지점이 주어지고 시작점으로 부터 종료지점까지 소모되는
비용을 최소로 하는 방법을 찾는 것인 반면

크루스칼 / 프림 알고리즘의 경우,
주어진 그래프에 대해서, 그래프의 모든 노드를 연결하는 가장 최소 비용의 방법을 찾는 것이다.
'''




'''
=======================================================================================================================
<<<다익스트라 알고리즘>>>

시작점 -> 목적지 로 가는 최단 거리를 구할 때 사용하는 알고리즘 중 하나로,
목적지로의 최단 거리 뿐 아니라, 시작점으로 부터 연결된 모든 노드에 대한 최단 거리를 구하는 작업이다.

알고리즘의 기본 개념은,
각 노드에 대한 최단 거리 리스트를 생성한 후, 해당 값을 계속 업데이트 해나가는 것이다.

	* 시간 복잡도는 O(V^2)
	모든 노드에 대해 수행(N) * 각 노드에 대해서 모든 간선에 대해서 비교(최대 N-1) = N^2


ex)
* 그래프는 여러 가지 형태로 입력 받을 수 있다.
  - 리스트의 index 값을 노드로 취급하는 경우 : index, (a, b) -> 출발 노드, (도착 노드, 비용)
  - 리스트의 원소로 출발 노드, 도착 노드, 비용을 모두 입력 받는 경우 : (a, b, c) -> (출발 노드, 도착 노드, 비용)
  - heapq를 사용할 경우에는, 노드의 번호보다 비용 값이 튜플의 앞 쪽에 와야한다 : index, (a, b) -> 출발 노드, (비용, 도착 노드)

graph =[[],
		[(2, 2), (3, 5), (4, 1)], # 1번 node에 연결된 node와 각 비용
		[(3, 3), (4, 2)], # 2번 node에 연결된 node와 각 비용
		[(2, 3), (6, 5)], # 3번 node에 연결된 node와 각 비용
		[(3, 3), (5, 1)], # 4번 node에 연결된 node와 각 비용
		[(3, 1), (6, 2)], # 5번 node에 연결된 node와 각 비용
		[]] # 6번 node에 연결된 node와 각 비용]

시작노드 = 1번

step 1.	시작노드에 직접 연결된 모든 노드에 대한 비용 업데이트
		1번 노드에 연결된, 2번/3번/4번 노드에 대한 비용 업데이트

step 2.	시작노드에서 가장 가까운 노드로 이동 / 해당 노드에 대한 방문 처리
		비용이 가장 적은 4번 노드로 이동
		4번 노드 방문 처리

step 3. 이동한 노드에 직접 연결된 모든 노드에 대한 비용 업데이트
		4번 노드에는 현재 3번/5번 노드가 연결되어 있다.
		5번 노드의 경우) 1 -> 4 -> 5로 이동한 것이며 따라서 비용은, 1 -> 4 (1) / 4 -> 5 (1) 을 더해 비용 2로 업데이트
		3번 노드의 경우) 1 -> 4 -> 3으로 이동한 것이며 따라서 비용은, 1 -> 4 (1) / 4 -> 3 (3) 을 더해 비용이 4로 계산된다.
		하지만! 3번 노드의 경우 1번 노드에 직접 연결되었었기 때문에 현재 비용이 5로 업데이트 되어있다.
		이런 경우 기존의 비용과 새로 계산된 비용을 비교하여 업데이트를 진행한다.
		위 경우, 1번에서 3번으로 직접가는 비용(5) 보다 1번에서 4번을 거쳐 3번으로 가는 비용(4)이 더 낮으므로 4로 업데이트

step 4. 다시 비용이 가장 적은(가장 가까운) 노드를 탐색한 후 이동
		1 -> 2 (2)
		1 -> 3 (4)
		1 -> 4 (1) (방문 완료)
		1 -> 5 (1)
		
		현재의 비용 값과 방문 여부를 확인하여, 다음 노드를 결정
		이 경우에는 4번 노드 / 5번 노드 방문 비용이 동일하지만 4번은 이미 방문했던 노드이기 때문에 4번이 아닌,
		5번 노드로 이동하여 동일한 작업을 반복한다.

		모든 노드에 대한 방문이 끝나고나면, 각 노드에 대한 최단 거리가 계산 된다.
		*** 그래프의 모든 노드는 연결되어 있다.
'''

def get_smallest_node():
	'''
	방문하지 않은 노드 중, 가장 비용이 낮은 노드를 찾는 작업
	'''
	min_value = INF # INF = int(1e9)
	index = 0

	for i in range(1, n+1):
		if (distance[i] < min_value) and (not visited[i]):
			min_value = distance[i]
			index = i

	return index


def dijkstra(start):
	'''
	start node에 대한 기본 처리
	'''
	distance[start] = 0
	visited[start] = True

	for (node, cost) in graph[start]:
		distance[node] = cost

	'''
	방문하지 않은 노드 중, 가장 비용이 낮은 노드를 찾은 후(방문 처리 수행),
	해당 노드에서 연결된 다른 노드로의 비용을 계산하여, distance 리스트 업데이트

	기존 코스트
	신규 코스트 - 현재 노드까지의 비용 + 현재 노드에서 다음 노드까지의 비용

	두 코스트 비교 후, 더 적은 비용으로 업데이트
	'''
	for i in range(n-1):
		now = get_smallest_node()
		visited[now] = True

		for (node, cost) in graph[now]:
			new_cost = distance[now] + cost

			if new_cost < distance[node]:
				distance[node] = new_cost

	return


# heapq를 이용한 다익스트라 알고리즘
import heapq

def dijkstra_heapq(start):
	q = []
	heapq.heappush(q, (0, start)) # heapq에 입력되는 것이 방문처리라고 생각하면 됨
	distance[start] = 0

	while q:
		dist, now = heapq.heappop()

		# 현재 노드가 이미 처리된 적이 있는 노드인가?
		if distance[now] < dist:
			continue

		for node, cost in graph[now]:
			new_cost = dist[now] + cost
			if dist[node] > new_cost:
				dist[node] = new_cost

				heapq.heappush(q, (new_cost, node))




'''
=======================================================================================================================
<<<플로이드 워셜 알고리즘>>>

모든 노드에서 모든 노드로의 최단 거리를 구하는 알고리즘

모든 노드에 대해서, 각 노드를 거쳐 갔을 때와, 거치지 않았을 때의 최단 거리를 비교하여
최단 거리를 최신화 시키는 방식의 알고리즘이다.

A번 노드 -> B번 노드로 가는 최단 거리에 대해서
(A번 노드 -> B번 노드)의 방법과 (A번 노드 -> C번 노드 -> B번 노드)의 방법 중 더 비용이 적은 값으로
최단 거리를 최신화 하는 방식

다만, 모든 노드에 대해서 모든 노드를 순회시켜야 하므로 시간 복잡도가 다익스트라 알고리즘에 비해 크다.

	* 시간 복잡도는 O(N^3)

ex)
* 다익스트라 알고리즘의 계산 때와 달리 그래프를 2차원 배열 형태로 입력 받는다.
  행(출발 노드) x 열(도착 노드) = 값(비용)

graph = [[INF, INF, INF, INF, INF],
		 [INF,   0,   4, INF,   6],
		 [INF,   3,   0,   7, INF],
		 [INF,   5, INF,   0,   4],
		 [INF, INF, INF,   2,   0]]

'''

def floyd_warshall():
	for node in range(1, n+1):
		for a in range(1, n+1):
			for b in range(1, n+1):
				if graph[a][b] > graph[a][node] + graph[node][b]:
					graph[a][b] = graph[a][node] + graph[node][b]
				# graph[a][b] = min(graph[a][b], graph[a][node] + graph[node][b])


'''
=======================================================================================================================
<<<벨만 포드 알고리즘>>>

음수 가중치가 있을 경우, 다익스트라 알고리즘으로는 최단 거리를 구할 수 없다.
이때 벨만 포드 알고리즘을 통해서 최단 거리를 계산할 수 있다.

왜냐하면, 다익스트라 알고리즘의 경우, 한 번 방문을 하게 되면 더 이상 해당 노드에 대한 방문을 진행하지 않게 되는데,
음수 가중치가 있을 경우, 음수의 가중치로 해당 노드를 방문하게 되면 최단 거리가 더 짧아지기 때문에 추가 적인 방문이 이루어져야만
최단 거리를 구할 수 있기 때문이다.

다익스트라 알고리즘과 달리 벨만 포드 알고리즘의 경우 모든 노드에 대한 방문을 반복적으로 수행하기 때문에 시간 복잡도는 더 크지만,
음수 가중치에 대한 처리도 가능하다.
'''

def bellman_ford(start):
	'''
	알고리즘의 전체적인 형태는 다익스트라 알고리즘과 매우 유사하다.
	'''
	distance[start] = 0

	for i in range(v): # 전체 node 순회
		for j in range(e):
			s_node = graph[j][0]
			e_node = graph[j][1]
			cost = graph[j][2]

			if (distance[s_node] != INF) and (distance[e_node] > distance[s_node] + cost):
				distance[e_node] = distance[s_node] + cost

				if i == v-1:
					return True

	return False